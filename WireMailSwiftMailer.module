<?php

/**
 * Swift Mailer WireMail module
 *
 * This module extends WireMail base class, integrating the Swift Mailer mailing
 * library into ProcessWire.
 *
 * @copyright Copyright (c) 2013-2014, Teppo Koivula
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License, version 2
 * 
 * ProcessWire 2.x 
 * Copyright (C) 2013 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://www.processwire.com
 *
 */
class WireMailSwiftMailer extends WireMail implements Module, ConfigurableModule, WireMailInterface {

    /**
     * Version number of Swift Mailer
     *
     */
    const SWIFT_VERSION = "5.2.1";

    /**
     * Container for Swift Mailer instance
     *
     */
    protected $swiftMailer;

    /**
     * Container for connection exception
     *
     */
    protected $exception;

    /**
     * getModuleInfo is a module required by all modules to tell ProcessWire about them
     *
     * @return array
     */
    public static function getModuleInfo() {
        return array(
            'title' => 'Swift Mailer',
            'summary' => __('WireMail module providing Swift Mailer integration'),
            'href' => 'http://modules.processwire.com/modules/wire-mail-swift-mailer/',
            'author' => 'Teppo Koivula',
            'version' => '0.1.11',
        );
    }

    /**
     * Default configuration for this module
     *
     * The point of putting this in it's own function is so that you don't have to specify
     * these defaults more than once.
     *
     * @return array
     */
    static public function getDefaultData() {
        return array(
            'transport' => 'Smtp',
            'SMTPPort' => '25',
            'defaultFrom' => 'processwire@' . wire('config')->httpHost,
            'defaultFromName' => 'ProcessWire',
        );
    }

    /**
     * Populate the default config data
     *
     * ProcessWire will automatically overwrite it with anything the user has specifically configured.
     * This is done in construct() rather than init() because ProcessWire populates config data after
     * construct(), but before init().
     *
     */
    public function __construct() {
        foreach(self::getDefaultData() as $key => $value) {
            $this->$key = $value;
        }
    }

    /**
     * Module configuration
     *
     * @param array $data
     * @return InputfieldWrapper
     */
    static public function getModuleConfigInputfields(array $data) {

        if (wire('input')->post->_checkConnection) {
            // make sure that module config data is up to date
            $configData = wire('modules')->getModuleConfigData(__CLASS__);
            $configDataChanged = false;
            foreach (wire('input')->post as $key => $value) {
                if (array_key_exists($key, $configData) && $configData[$key] != $value) {
                    $configData[$key] = $value;
                    $configDataChanged = true;
                }
            }
            if ($configDataChanged) {
                wire('modules')->saveModuleConfigData(__CLASS__, $configData);
            }
            // check connection and alert the user if there's a problem
            $swiftMailer = wire('modules')->get('WireMailSwiftMailer');
            $result = $swiftMailer->checkConnection();
            if ($result) {
                wire()->message(__("Connection checked and everything seems to be working just fine. You're good to go."));
            } else {
                $exception = $swiftMailer->getException();
                if ($exception) wire()->error($exception->getMessage());
                wire()->error(__("Connection problem detected, please check your settings or select another method of transport. ProcessWire may not be able to send email at the moment."));
            }
            // store timestamp and result of this check to module config
            $configData['connectionStatus'] = (int) $result . "|" . time();
            $data['connectionStatus'] = $configData['connectionStatus'];
            wire('modules')->saveModuleConfigData(__CLASS__, $configData);
            wire('session')->redirect('./edit?name=' . __CLASS__, false);
        }

        // this is a container for fields, basically like a fieldset
        $fields = new InputfieldWrapper();

        // since this is a static function, we can't use $this->modules, so get them from the global wire() function
        $modules = wire('modules');

        // merge default config settings (custom values overwrite defaults)
        $defaults = self::getDefaultData();
        $data = array_merge($defaults, $data);

        // special handling for SMTP password
        if (isset($data['SMTPPassword2'])) {
            $data['SMTPPassword'] = $data['SMTPPassword2'];
            unset($data['SMTPPassword2'], $data['clearSMTPPassword']);
            wire('modules')->saveModuleConfigData(__CLASS__, $data);
        } else if (isset($data['clearSMTPPassword']) && $data['clearSMTPPassword']) {
            unset($data['SMTPPassword'], $data['SMTPPassword2'], $data['clearSMTPPassword']);
            wire('modules')->saveModuleConfigData(__CLASS__, $data);
        } else {
            unset($data['SMTPPassword2'], $data['clearSMTPPassword']);
            wire('modules')->saveModuleConfigData(__CLASS__, $data);
        }

        // Sender address
        $field = $modules->get("InputfieldText");
        $field->name = "defaultFrom";
        $field->label = __("Sender Address");
        $field->required = true;
        if (isset($data[$field->name])) $field->value = $data[$field->name];
        $fields->add($field);

        // Sender name
        $field = $modules->get("InputfieldText");
        $field->name = "defaultFromName";
        $field->label = __("Sender Name");
        if (isset($data[$field->name])) $field->value = $data[$field->name];
        $fields->add($field);
        
        // Transport
        $field = $modules->get("InputfieldSelect");
        $field->name = "transport";
        $field->label = __("Transport");
        $field->notes = __("See [Swift Mailer Documentation](http://swiftmailer.org/docs/sending.html#transport-types) for detailed description for each individual Transport.");
        $field->required = true;
        $field->addOptions(array(
            'Smtp' => 'SMTP',
            'Sendmail' => 'Sendmail',
            'Mail' => 'Mail'
        ));
        if (isset($data[$field->name])) $field->value = $data[$field->name];
        $fields->add($field);

        // common container (fieldset) for SMTP settings
        $fieldset = $modules->get("InputfieldFieldset");
        $fieldset->showIf = "transport=Smtp";
        $fieldset->label = __("SMTP Transport Settings");

        // SMTP server name
        $field = $modules->get("InputfieldText");
        $field->name = "SMTPServer";
        $field->label = __("SMTP server name");
        $field->required = true;
        $field->requiredIf = "transport=Smtp";
        if (isset($data[$field->name])) $field->value = $data[$field->name];
        $fieldset->add($field);

        // SMTP server port
        $field = $modules->get("InputfieldText");
        $field->name = "SMTPPort";
        $field->label = __("SMTP server port");
        $field->required = true;
        $field->requiredIf = "transport=Smtp";
        if (isset($data[$field->name])) $field->value = $data[$field->name];
        $fieldset->add($field);

        // SMTP encryption
        $field = $modules->get("InputfieldSelect");
        $field->name = "SMTPEncryption";
        $field->label = __("SMTP encryption");
        $field->addOptions(array(
            __('None'),
            'ssl' => 'SSL',
            'tls' => 'TLS',
        ));
        if (isset($data[$field->name])) $field->value = $data[$field->name];
        $fieldset->add($field);

        // SMTP username
        $field = $modules->get("InputfieldText");
        $field->name = "SMTPUsername";
        $field->label = __("SMTP username");
        if (isset($data[$field->name])) $field->value = $data[$field->name];
        $fieldset->add($field);

        // SMTP password
        $field = $modules->get("InputfieldText");
        $field->collapsed = true;
        $field->type = "password";
        $field->name = "SMTPPassword2";
        $field->label = __("SMTP password");
        $field->notes = __("Note: password is stored as plain text in database. THIS IS NOT SECURE. Don't use this setting unless you're fully aware of it's consequences!");
        $field->columnWidth = 75;
        $fieldset->add($field);

        // clear SMTP password?
        $field = $modules->get("InputfieldCheckbox");
        $field->collapsed = true;
        $field->name = "clearSMTPPassword";
        $field->label = __("Clear password?");
        $field->notes = __("Check and save form to clear stored password.");
        $field->columnWidth = 25;
        $fieldset->add($field);

        // add SMTP fields
        $fields->add($fieldset);

        // Sendmail command
        $field = $modules->get("InputfieldText");
        $field->showIf = "transport=Sendmail";
        $field->name = "SendmailCommand";
        $field->label = __("Sendmail command");
        $field->notes = __("Default value when left blank is /usr/sbin/sendmail -bs");
        if (isset($data[$field->name])) $field->value = $data[$field->name];
        $fields->add($field);

        // check connection
        $field = $modules->get("InputfieldCheckbox");
        $field->icon = "bolt";
        $field->name = "_checkConnection";
        $field->label = __("Check connection");
        $field->label2 = __("Check connection now");
        $field->description = __("Check this field if you want to run connection test after submitting module settings.");
        if (isset($data['connectionStatus'])) {
            $status = explode("|", $data['connectionStatus']);
            $status_texts = array(
                0 => __("Previous check performed %s was a failure."),
                1 => __("Previous check performed %s was a success."),
            );
            $field->notes = sprintf($status_texts[$status[0]], date("j.n.Y H:i", $status[1]));
        }
        $fields->add($field);

        return $fields;

    }

    /**
     * Initialize the module
     *
     * ProcessWire calls this when the module is loaded. For 'autoload' modules, this will be called
     * when ProcessWire's API is ready. As a result, this is a good place to attach hooks. 
     *
     * @throws WireException if unrecognized (invalid) transport setting was defined
     */
    public function init() {

        // if SMTP is selected but not yet properly configured, fallback to Mail
        if ($this->transport == "Smtp" && !($this->SMTPServer && $this->SMTPPort)) {
            $this->transport = "Mail";
        }

        // init and configure Swift Mailer
        require_once(dirname(__FILE__) . "/Swift-" . self::SWIFT_VERSION . "/lib/swift_required.php");
        switch ($this->transport) {
            case "Smtp":
                $transport = Swift_SmtpTransport::newInstance($this->SMTPServer, $this->SMTPPort);
                if ($this->SMTPUsername) $transport->setUsername($this->SMTPUsername);
                if ($this->SMTPPassword) $transport->setPassword($this->SMTPPassword);
                if ($this->SMTPEncryption) $transport->setEncryption($this->SMTPEncryption);
                break;
            case "Sendmail":
                $transport = Swift_SendmailTransport::newInstance($this->SendmailCommand);
                break;
            case "Mail":
                $transport = Swift_MailTransport::newInstance($this->SMTPServer, $this->SMTPPort);
                break;
            default:
                throw new WireException("Transport setting not recognized");
        }
        $this->swiftMailer = Swift_Mailer::newInstance($transport);

    }

    /**
     * Send email using Swift Mailer send() function
     *
     * @return int number of recipients accepted for delivery
     */
    public function ___send() {

        // create the message
        $message = Swift_Message::newInstance()
            ->setTo($this->to)
            ->setSubject($this->subject);

        // set body (plain text and/or HTML)
        if ($this->body) $message->setBody($this->body);
        if ($this->bodyHTML) {
            if ($this->body) $message->addPart($this->bodyHTML, "text/html");
            else $message->setBody($this->bodyHTML, "text/html");
        }

        // set the From address with an associative array
        $from = $this->from ? $this->from : $this->defaultFrom;
        $fromName = $this->fromName ? $this->fromName : $this->defaultFromName;
        $message->setFrom($fromName ? array($from => $fromName) : array($from));

        // set extra headers
        if ($this->header) {
            $headers = $message->getHeaders();
            foreach ($this->header as $name => $value) {
                $headers->addTextHeader($name, $value);
            }
        }

        return $this->swiftMailer->send($message);

    }

    /**
     * Check if SMTP connection is available
     *
     * This is mostly useful for SMTP, but can also be used to check if Swift
     * Mailer has been properly loaded and instantiated. If an SMTP connection
     * fails, you can get the caught exception with getException().
     * 
     * @return bool TRUE if connection is OK, FALSE if not
     */
    public function checkConnection() {
        if (!$this->swiftMailer) return false;
        if ($this->transport == "Smtp") {
            try {
                $this->swiftMailer->getTransport()->start();
            } catch (Swift_TransportException $e) {
                $this->exception = $e;
                return false;
            }
        }
        return true;
    }

    /**
     * Return SMTP connection exception (if exists)
     *
     * @return null|Swift_TransportException
     */
    public function getException() {
        return $this->exception;
    }

}